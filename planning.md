
---

**`PLANNING.md`**

```markdown
# Development Plan - StorySpark AI

## Introduction

This document outlines the iterative development plan for the StorySpark AI project. The approach emphasizes building functionality in small, manageable steps, starting with a Command Line Interface (CLI) to validate core logic before moving to a web interface and more complex features like audio and image generation.

## Core Principles

*   **Iterative Development:** Build features in distinct phases and work packages.
*   **CLI First:** Validate core AI interactions and logic via the command line.
*   **Separation of Concerns:** Develop text generation, series management, audio, and UI features somewhat independently before integrating.
*   **Focus on MVP:** Get the essential story creation loop working first.

## Phased Development Plan

---

### Phase 0: Foundation & Basic Text Generation (CLI)

*   **Goal:** Set up the project and get a single, non-interactive piece of text generated by the LLM based on minimal input.
*   **WP 0.1: Environment Setup**
    *   Tasks: Project directory, Python venv, Git repo, `.gitignore`, `requirements.txt`.
    *   Output: Clean project structure.
*   **WP 0.2: API Key Setup & Basic LLM Call**
    *   Tasks: Get LLM API key, store securely (`.env`), script (`generate_test.py`) for basic hardcoded prompt -> LLM call -> print response. Basic API error handling.
    *   Output: Proof of API communication.
*   **WP 0.3: Simple Parameter Input (CLI)**
    *   Tasks: Modify script (`create_story_cli.py`) to accept character names via `argparse`. Use names in LLM prompt.
    *   Output: Script generates starting paragraph based on CLI input.

---

### Phase 1: Interactive Text Story Creation (CLI)

*   **Goal:** Implement the core choose-your-own-adventure loop purely with text generation and basic state management.
*   **WP 1.1: LLM Generates Choices**
    *   Tasks: Refine LLM prompt for story segment + 2-3 numbered choices. Parse response, print story & choices.
    *   Output: Script displays story segment and actionable choices.
*   **WP 1.2: User Choice & Loop**
    *   Tasks: Add logic for user choice input. Implement loop: Send context + choice -> Get next segment + choices -> Display -> Get input -> Repeat.
    *   Output: Basic interactive story loop in console.
*   **WP 1.3: Basic State Management (JSON)**
    *   Tasks: Define JSON structure (`story_data.json`) for metadata + list of segments/events. Script loads/appends state, builds context from history.
    *   Output: Story text persisted in JSON.
*   **WP 1.4: Define Story End Condition**
    *   Tasks: Implement end condition (e.g., fixed # loops). Print "Story Complete", save final JSON.
    *   Output: Stories have a defined end point.

---

### Phase 2: Implementing the "Series" Framework (CLI)

*   **Goal:** Allow defining persistent characters/settings and using them in story generation.
*   **WP 2.1: Series Data Structure (JSON)**
    *   Tasks: Design JSON (`series_[name].json`) for Series Name, Characters+Traits, Locations.
    *   Output: Defined format for series info.
*   **WP 2.2: Basic Series Management (CLI)**
    *   Tasks: Add CLI commands (`--create-series`, `--list-series`) to manage series JSON files.
    *   Output: Ability to create/view series definitions via CLI.
*   **WP 2.3: Use Series Data in Story Generation**
    *   Tasks: Modify story creation script to accept `--series [name]`. Load series data, inject into LLM prompts. Link saved story JSON to series.
    *   Output: Stories generated reflect chosen series elements.
*   **WP 2.4: Refine LLM Prompting ("Red Thread")**
    *   Tasks: Experiment with prompt engineering for plot outlining (initial LLM call?) and including the goal/outline in subsequent prompts.
    *   Output: Improved story coherence (iterative testing needed).

---

### Phase 3: Adding Audio Generation (CLI)

*   **Goal:** Integrate TTS (e.g., ElevenLabs) to create an audiobook file from the completed text story.
*   **WP 3.1: Basic TTS Integration**
    *   Tasks: Get TTS API key. Add script/function (`generate_audio.py`) taking story JSON path -> extract text -> call TTS API -> save MP3. Handle API errors.
    *   Output: MP3 file generated from a story JSON.
*   **WP 3.2: Link Audio File in Data**
    *   Tasks: Modify story JSON structure to include `audioFilePath`. Update script to save this path after audio generation.
    *   Output: Story JSON references its audio file.
*   **WP 3.3: (Optional) Trigger Audio Gen Post-Creation**
    *   Tasks: Modify story creation script to optionally call audio generation upon completion (e.g., via `--generate-audio` flag).
    *   Output: Streamlined text -> audio flow (CLI).

---

### Phase 4: Basic Web Interface (Read & Listen Focus)

*   **Goal:** Create a minimal web UI to browse, read, and listen to stories.
*   **WP 4.1: Web Server & Framework Setup**
    *   Tasks: Choose/set up web framework (Flask/FastAPI). Basic server structure.
    *   Output: Running local web server.
*   **WP 4.2: Story Library View (Read)**
    *   Tasks: Route/page listing stories (from JSONs). Link to "Read" view. "Read" view displays formatted text from JSON.
    *   Output: Browse/read stories in browser.
*   **WP 4.3: Audio Playback (Listen)**
    *   Tasks: Add "Listen" button. Route serves MP3 file (from `audioFilePath` in JSON). Frontend HTML5 `<audio>` player.
    *   Output: Listen to audiobooks via web UI.
*   **WP 4.4: (Optional) Basic Web Creation Form**
    *   Tasks: Simple web form for basic inputs (Characters, Series). Backend triggers existing CLI logic.
    *   Output: Basic story initiation via web UI.

---

### Subsequent Phases (Higher Level Goals)

*   **Phase 5: Enhance Web UI & Creation:** Full web-based creation flow, series management UI, "Create/Listen/Read" tabs, bookshelf view, potential DB migration (Pocketbase/PostgreSQL).
*   **Phase 6: Image Generation:** Integrate Image LLM API, generate/store images, display in "Read" view. Explore personalized image generation using uploaded base images.
*   **Phase 7: Advanced Features:** Print-on-Demand integration, educational theme selection, undo/regenerate functionality (potentially premium), user accounts.
*   **Phase 8: Polish & Potential Sharing:** UI/UX refinement, robust error handling, performance tuning, investigate marketplace/sharing features.

---